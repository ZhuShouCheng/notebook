## Part 1: PC Bootstrap

#### x86汇编

##### AT&T语法

mov ebx,eax	操作数在左，目标数在右

立即数前面加"$"，寄存器前面加"%"

cmpl指令将两个操作数相减，但计算结果并不保存，只是根据计算结果改变eflags寄存器中的标志位，如果两个操作数相等，则计算结果为0，eflags中的ZF位置1。

jne	条件转移指令(jump not equal) ZF=0，则进行跳转

xor	异或指令

cmp	比较两操作数大小

CLI：Clear Interupt，禁止中断发生。STL：Set Interupt，允许中断发生。CLI和STI是用来屏蔽中断和恢复中断用的，如设置栈基址SS和偏移地址SP时，需要CLI，因为如果这两条指令被分开了，那么很有可能SS被修改了，但由于中断，而代码跳去其它地方执行了，SP还没来得及修改，就有可能出错。
CLD: Clear Director。STD：Set Director。在字行块传送时使用的，它们决定了块传送的方向。CLD使得传送方向从低地址到高地址，而STD则相反。

LIDT: 加载中断描述符。LGDT：加载全局描述符。



-------------------------

#### 物理地址空间

```
+------------------+  <- 0xFFFFFFFF (4GB)
|      32-bit      |
|  memory mapped   |
|     devices      |
|                  |
/\/\/\/\/\/\/\/\/\/\

/\/\/\/\/\/\/\/\/\/\
|                  |
|      Unused      |
|                  |
+------------------+  <- depends on amount of RAM
|                  |
|                  |
| Extended Memory  |
|                  |
|                  |
+------------------+  <- 0x00100000 (1MB)
|     BIOS ROM     |
+------------------+  <- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  <- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  <- 0x000A0000 (640KB)
|                  |
|    Low Memory    |
|                  |
+------------------+  <- 0x00000000
```

Low Memory ???	早期计算机使用？

BIOS	完成机器自检，对系统进行初始化，如加载显卡和检查内存总量，执行完初始化操作后，将从适当的位置加载操作系统，并将计算机的控制权传递给操作系统。早期的BIOS写在ROM（只读存储器）中，但当前PC将BIOS存储在闪存中。

Low 1MB	现代PC保留了原始布局，用于向后兼容，如286在实模式下运行。（最初的IBM PC中的Intel 8088 CPU能够寻址1MB，故称为1MB障碍。后来的Intel 80286和80386打破了1MB障碍）

#### The ROM BIOS

CS	代码段寄存器

IP	指令寄存器

``` 
[f000:fff0] 0xffff0:	ljmp   $0xf000,$0xe05b
  CS   IP
```

由于PC中的BIOS是“硬连线”到物理地址范围0x000f0000-0x000fffff，因此该设计可确保BIOS始终在上电或任何系统重新启动后始终首先获得对计算机的控制-这是至关重要的，因为在通电时， 机器的RAM中没有其他软件可以执行的软件。

在实模式中，物理地址= 16 * 端地址 + 偏移量

```
 16 * 0xf000 + 0xfff0  = 0xf0000 + 0xfff0 = 0xffff0 
```





## Part 2:The Boot Loader

PC上的软盘和硬盘被分为512字节区域，称为扇区

如果磁盘可引导，则第一个扇区被称为引导扇区，引导加载程序代码所在

JOS 的引导由`boot/boot.S`的汇编程序和`boot/main.c`的C程序两个程序完成

#### boot.S

主要是将将处理器从实模式转换到 32 位的保护模式

1. 初始化常用寄存器
2. 打开A20地址线，让程序可以访问1MB以上的内存地址
3. 加载全局描述符表，打开保护模式
4. 执行bootmain函数

##### bootmain.c

读取第一个扇区，运行内核

##### 

##### GDB命令

- ctrl-c 中止当前程序运行，进入gdb

- c 继续运行到断点位置

- si 执行一条指令

- b function/b file:line 在function处设置断点

- b *addr 在某地址处设置断点

- x/ni 显示接下来n条指令  x/nx add显示接下来n个16进制 +add 用来打印add地址中存储的数据

  

