# SM2 算法原理及实现

## 原理

#### SM2算法介绍

我国自主知识产权的商业密码算法，是ECC（椭圆加密算法）的一种，基于椭圆曲线离散对数问题（公钥密码体制所依据的难题主要为大素数分解问题、离散对数问题、椭圆曲线），计算复杂度是指数级。同等安全条件下，椭圆曲线密码较其他公钥算法所需密钥长度小很多。

#### ECC算法原理

-------------------------

##### 个人理解（杂乱）

椭圆曲线上一点 A(x,y)

随机生成的私钥k

kx ky拼接得到公钥P （ kx为椭圆乘法）

椭圆加法 A+B等于A B的连线交椭圆曲线于另一点C 做C点延X轴的对称轴 此点即为 A+B

<img src="pic\椭圆加法.png" alt="椭圆加法.png"  />

A+A 即为A点在椭圆曲线的切线交曲线于一点 其关于X轴对称的点

可以通过2A直接算出4A 以此类推 8 、16、64...可以快速算出kA

要求把这条椭圆曲线定义在某个质数阶P的有限域上   -->	画出来离散点图

<img src="pic\质数域上的椭圆曲线.png"  />

ECC公钥的特点：		（NP问题）

- 即使P已知，依旧很难求出K值
- 对给定的K值，可以在多项式时间内验证   

![ ](pic\ECC的加密、签名.png)

-------------------------

##### ECC原理介绍

ECC全称 Ellipse Curve Ctyptography，是一种基于椭圆曲线数学的公开加密算法。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。与传统的基于大质数分解难题的加密算法不同，该加密方式基于离散对数数学难题。该算法的主要优势是可以使用更小的密钥提供相当高等级的安全。ECC164位密钥产生一个安全级，相当于RSA 1024位密钥提供的保密强度，而且计算量较小，处理速度更快，存储空间和传输带宽占用较少。目前我国居民二代身份证正在使用256位的椭圆曲线密码。虚拟货币比特币也使用ECC作为加密算法。

-------

##### ElGamal离散对数密码体制

（一）公钥密钥生成

1. Alice首先构造一条椭圆曲线E，在曲线上选择一点G作为生成元，并求G的阶为n，要求n必须为质数。此时构成了一个循环群\<G>。

2. Alice选择一个私钥k (k < n),生成公钥 Q = kG

3. Alice将公钥组E、Q、G发送给Bob

（二）加密过程

1. Bob收到信息后，将明文编码为M，M为曲线上一点，并选择一个随机数r（r < n, n为G的阶）
2. 2.Bob计算点Cipher1与Cipher2即两段密文，计算方法如下

- Cipher1 = M + rQ
- Cipher2 = rG

3. Bob把Cipher1和Cipher2发给Alice

（三）解密过程

1. Alice收到密文后，为了获得M，只需要Cipher1 - k · Cipher2,因为

```python
Cipher1 - k*Cipher2 = M + rQ - krG = M + rkG - krG = M
```

2. 将M解码即可

-----------

##### ECDSA数字签名算法



------------

## SM2官方文档

#### 总则

1. 规定了椭圆曲线的系统参数以及验证方法
2. 规定了椭圆曲线公钥的验证方法
3. 附录中给出了椭圆曲线示例

[国家商业密码标准](http://www.gmbz.org.cn/main/bzlb.html)

##### Q:

1. 验证[n]P-O是干啥的（公钥验证）
2. F2m是什么意思？

#### 第二部分 数字签名算法

##### 签名算法流程

（一）置M' = ZA || M    M为待签名数据  ZA为A的可辨识标识、部分椭圆曲线系统参数和用户A的公钥的Hash值

（二）计算e = Hash(M') 并将其转化为整数

（三）用随机数发生器生成随机数k (k>1 k< n-1)     n  椭圆曲线的阶数  可以通过G计算出

（四）计算椭圆曲线点(x1,y1) = [k]G，并将其转化为整数	G为椭圆上一点 [k]G指椭圆乘法k倍G

（五）计算r= (e + x1)mod n，若r=0或r+k=n返回（三）

（六）计算s= ((1+da) ^(-1) * (k-r*da))mod n，若s=0则返回（三）    da为用户A的私钥

（七）将r、s数据类型转化成字节串，消息M的签名为(r,s)

##### 验签算法流程

（一）验证r>1 r<n-1

（二）验证s>1 s<n-1

（三）置M' = ZA || M

（四）计算e = Hash(M') 并将其转化为整数

（五）将r s数据类型转换为整数 计算 t= (r+s)mod n ，若t=0则验证不通过

（六）计算椭圆曲线点(x1,y1) = [s]G + [t]Pa	Pa为A的公钥

（七） 将x1的数据类型转换成整数，计算R=(e+x1)mod n，验证R=r，成立则验证通过

#### 第三部分 密钥交换协议

##### 密钥交换流程

#### 第四部分 公钥加密算法

##### 加密算法流程

（一）用随机数发生器产生随机数k (k>1 k<n-1)

（二）计算椭圆曲线点C1=[k]G=(x1,y1)，并将其转换为比特串（A的私钥生成公钥）

（三）计算椭圆曲线点S=[h]Pb，若S是无穷远点，则报错并退出    h为n的余因子

（四）计算椭圆曲线点[k]Pb=(x2,y2)，并将其转换为比特串（A的私钥乘B的公钥）

（五）计算t=KDF(x2||y2,klen)，若t为全0比特串，则返回（一）  KDF为密钥派生函数

（六）计算C2=M⊕t

（七）计算C3=Hash(x2||M||y2)

（八）输出密文C=C1||C3||C2

##### 解密算法流程

（一）从C中取出比特串C1，将其转换为椭圆曲线上的点，验证C1是否满足椭圆曲线方程

（二）计算椭圆曲线点S=[h]Pb，若S是无穷远点，则报错并退出 

（三）计算[db]C1=(x2,y2)，并将其转换为比特串	db B的公钥

（四）计算t=KDF(x2||y2,klen)，若t为全0比特串，则返回（一）  KDF为密钥派生函数

（五）从C中取出比特串C2,计算M=C2⊕t

（六）计算u=Hash(x2||M||y2)，从C中取出比特串C3，若u不等于C3，则报错并退出

（七）输出明文M

#### 第五部分 参数定义

给出了SM2使用素数域256位椭圆曲线参数

------------

## SM2 算法实现

#### 参数定义&名词解释

默认用户id	default_uid = []byte{0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38}

​	该参数由《SM2密码算法使用规范》指定

big-endian	大端模式，指数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中，常用的X86结构是小端模式

scalar	标量

p256Params.N	椭圆曲线的阶数

##### Question

sm2 Line 398	entla的值是什么 如何计算 